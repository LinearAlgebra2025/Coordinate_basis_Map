<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>交互式地图坐标系工具</title>
  <style>
    body { font-family: 微软雅黑, sans-serif; text-align: center; }
    canvas { border: 1px solid black; margin-top: 10px; cursor: crosshair; }
    #controls { margin: 10px; }
    .coords { margin-top: 10px; white-space: pre-line; text-align: left; display: inline-block; }
  </style>
</head>
<body>
  <h2>交互式地图坐标系工具</h2>
  <div id="controls">
    <input type="file" id="upload" accept="image/*">
    <button id="reset">重置</button>
  </div>
  <canvas id="canvas" width="600" height="600"></canvas>
  <div class="coords" id="output"></div>

  <script>
    const upload = document.getElementById("upload");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const resetBtn = document.getElementById("reset");
    const output = document.getElementById("output");

    let img = new Image();
    let targetPoint = null; 
    let tempPoints = [];    
    let systems = [];       
    const colors = ["red", "blue", "green", "purple", "orange", "brown"];

    let dragging = false;
    let hasImage = false; // 是否用户上传了图片
    const gridSize = 50;  // 网格间隔
    const center = {x: 300, y: 300}; // 默认坐标系原点

    // ========== 辅助函数 ==========
    function getLuminance(r, g, b) {
      return 0.299 * r + 0.587 * g + 0.114 * b;
    }

    function drawTextWithContrast(ctx, text, x, y) {
      const pixel = ctx.getImageData(Math.min(x, canvas.width-1), Math.min(y, canvas.height-1), 1, 1).data;
      const lum = getLuminance(pixel[0], pixel[1], pixel[2]);
      ctx.fillStyle = lum > 128 ? "black" : "white";
      ctx.fillText(text, x, y);
    }

    // ========== 绘制默认坐标系 ==========
    function drawDefaultGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      // 网格线
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;

      // 坐标轴
      ctx.beginPath();
      ctx.moveTo(0, center.y);
      ctx.lineTo(canvas.width, center.y);
      ctx.moveTo(center.x, 0);
      ctx.lineTo(center.x, canvas.height);
      ctx.stroke();

      // 箭头 X
      ctx.beginPath();
      ctx.moveTo(canvas.width-10, center.y);
      ctx.lineTo(canvas.width-20, center.y-5);
      ctx.lineTo(canvas.width-20, center.y+5);
      ctx.closePath();
      ctx.fill();

      // 箭头 Y
      ctx.beginPath();
      ctx.moveTo(center.x, 10);
      ctx.lineTo(center.x-5, 20);
      ctx.lineTo(center.x+5, 20);
      ctx.closePath();
      ctx.fill();

      // 坐标轴标签
      ctx.font = "bold 20px 微软雅黑";
      drawTextWithContrast(ctx, "X", canvas.width-30, center.y-15);
      drawTextWithContrast(ctx, "Y", center.x+15, 25);

      // 刻度
      ctx.font = "bold 16px 微软雅黑";
      for (let i = -5; i <= 5; i++) {
        if (i !== 0) {
          // X轴刻度
          ctx.beginPath();
          ctx.moveTo(center.x + i*gridSize, center.y-6);
          ctx.lineTo(center.x + i*gridSize, center.y+6);
          ctx.stroke();
          drawTextWithContrast(ctx, i.toString(), center.x + i*gridSize-8, center.y+25);

          // Y轴刻度
          ctx.beginPath();
          ctx.moveTo(center.x-6, center.y - i*gridSize);
          ctx.lineTo(center.x+6, center.y - i*gridSize);
          ctx.stroke();
          drawTextWithContrast(ctx, i.toString(), center.x+12, center.y - i*gridSize+6);
        }
      }
    }

    // 初始显示标准坐标系
    drawDefaultGrid();

    // 上传图片
    upload.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          hasImage = true;
          redraw();
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    // 鼠标事件
    canvas.addEventListener("mousedown", e => {
      let {x, y} = getMousePos(e);

      if (!hasImage) {
        // 吸附到整格点
        x = Math.round((x - center.x) / gridSize) * gridSize + center.x;
        y = Math.round((y - center.y) / gridSize) * gridSize + center.y;
      }

      if (targetPoint && distance(x, y, targetPoint.x, targetPoint.y) < 8) {
        dragging = true;
      } else if (!targetPoint) {
        targetPoint = {x, y};
        redraw();
      } else {
        tempPoints.push({x, y});
        if (tempPoints.length === 3) {
          createSystem(targetPoint, tempPoints[0], tempPoints[1], tempPoints[2]);
          tempPoints = [];
        }
        redraw();
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (dragging && targetPoint) {
        let {x, y} = getMousePos(e);
        if (!hasImage) {
          x = Math.round((x - center.x) / gridSize) * gridSize + center.x;
          y = Math.round((y - center.y) / gridSize) * gridSize + center.y;
        }
        targetPoint.x = x;
        targetPoint.y = y;
        redraw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {x: e.clientX - rect.left, y: e.clientY - rect.top};
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
    }

    function createSystem(P, O, Xp, Yp) {
      const color = colors[systems.length % colors.length];
      systems.push({color, O, Xp, Yp});
    }

    function redraw() {
      if (hasImage && img.src) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      } else {
        drawDefaultGrid();
      }

      if (targetPoint) {
        drawPoint(targetPoint, "black");
      }
      tempPoints.forEach(p => drawPoint(p, "gray"));

      output.innerHTML = "";
      systems.forEach((s, i) => {
        drawVector(s.O, s.Xp, s.color);
        drawVector(s.O, s.Yp, s.color);
        if (targetPoint) {
          const coords = computeCoords(targetPoint, s.O, s.Xp, s.Yp);
          output.innerHTML += `坐标系 ${i+1} (${s.color}): (${coords[0].toFixed(2)}, ${coords[1].toFixed(2)})\n`;
          drawLabel(targetPoint, coords[0], coords[1], s.color, i+1);
        }
      });
    }

    function computeCoords(P, O, Xp, Yp) {
      const Px = P.x - O.x;
      const Py = P.y - O.y;
      const Xv = [Xp.x - O.x, Xp.y - O.y];
      const Yv = [Yp.x - O.x, Yp.y - O.y];
      const det = Xv[0]*Yv[1] - Xv[1]*Yv[0];
      if (Math.abs(det) < 1e-6) return [NaN, NaN];
      const a = (Px*Yv[1] - Py*Yv[0]) / det;
      const b = (Py*Xv[0] - Px*Xv[1]) / det;
      return [a, b];
    }

    function drawPoint(P, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(P.x, P.y, 5, 0, Math.PI*2);
      ctx.fill();
    }

    function drawVector(O, P, color) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(O.x, O.y);
      ctx.lineTo(P.x, P.y);
      ctx.stroke();

      const angle = Math.atan2(P.y - O.y, P.x - O.x);
      const headlen = 12;
      ctx.beginPath();
      ctx.moveTo(P.x, P.y);
      ctx.lineTo(P.x - headlen*Math.cos(angle - Math.PI/6),
                 P.y - headlen*Math.sin(angle - Math.PI/6));
      ctx.lineTo(P.x - headlen*Math.cos(angle + Math.PI/6),
                 P.y - headlen*Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawLabel(P, a, b, color, index) {
      ctx.fillStyle = color;  // 每个系统用自己的颜色
      ctx.font = "bold 18px 微软雅黑";
      ctx.fillText(`系${index}: (${a.toFixed(2)}, ${b.toFixed(2)})`, P.x + 12, P.y - 18*index);
    }

    resetBtn.addEventListener("click", () => {
      targetPoint = null;
      tempPoints = [];
      systems = [];
      hasImage = false;
      canvas.width = 600;
      canvas.height = 600;
      drawDefaultGrid();
      output.innerHTML = "";
    });
  </script>
</body>
</html>
