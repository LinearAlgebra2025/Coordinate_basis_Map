<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>交互式地图坐标系工具</title>
  <style>
    body { font-family: 微软雅黑, sans-serif; text-align: center; }
    canvas { border: 1px solid black; margin-top: 10px; cursor: crosshair; }
    #controls { margin: 10px; }
    .coords { margin-top: 10px; white-space: pre-line; text-align: left; display: inline-block; }
  </style>
</head>
<body>
  <h2>交互式地图坐标系工具</h2>
  <div id="controls">
    <input type="file" id="upload" accept="image/*">
    <button id="reset">重置</button>
  </div>
  <canvas id="canvas"></canvas>
  <div class="coords" id="output"></div>

  <script>
    const upload = document.getElementById("upload");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const resetBtn = document.getElementById("reset");
    const output = document.getElementById("output");

    let img = new Image();
    let targetPoint = null; // 目标点
    let tempPoints = [];    // 临时存放 [观察点, x方向点, y方向点]
    let systems = [];       // 多个坐标系
    const colors = ["red", "blue", "green", "purple", "orange", "brown"];

    // 拖动目标点
    let dragging = false;

    // 上传图片
    upload.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          redraw();
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    // 点击画布
    canvas.addEventListener("mousedown", e => {
      if (!img.src) return;
      const {x, y} = getMousePos(e);
      if (targetPoint && distance(x, y, targetPoint.x, targetPoint.y) < 8) {
        dragging = true;
      } else if (!targetPoint) {
        // 设置目标点
        targetPoint = {x, y};
        redraw();
      } else {
        // 添加观察点、x方向点、y方向点
        tempPoints.push({x, y});
        if (tempPoints.length === 3) {
          createSystem(targetPoint, tempPoints[0], tempPoints[1], tempPoints[2]);
          tempPoints = [];
          redraw();
        } else {
          redraw();
        }
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (dragging && targetPoint) {
        const {x, y} = getMousePos(e);
        targetPoint.x = x;
        targetPoint.y = y;
        redraw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
    });

    // 获取鼠标位置
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {x: e.clientX - rect.left, y: e.clientY - rect.top};
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
    }

    // 创建坐标系
    function createSystem(P, O, Xp, Yp) {
      const color = colors[systems.length % colors.length];
      systems.push({color, O, Xp, Yp});
    }

    // 重新绘制所有内容
    function redraw() {
      if (!img.src) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      if (targetPoint) {
        drawPoint(targetPoint, "black");
      }

      // 临时点（灰色）
      tempPoints.forEach(p => drawPoint(p, "gray"));

      // 绘制所有坐标系
      output.innerHTML = "";
      systems.forEach((s, i) => {
        drawVector(s.O, s.Xp, s.color);
        drawVector(s.O, s.Yp, s.color);

        if (targetPoint) {
          const coords = computeCoords(targetPoint, s.O, s.Xp, s.Yp);
          output.innerHTML += `坐标系 ${i+1} (${s.color}): (${coords[0].toFixed(2)}, ${coords[1].toFixed(2)})\n`;
          drawLabel(targetPoint, coords[0], coords[1], s.color, i+1);
        }
      });
    }

    // 计算局部坐标
    function computeCoords(P, O, Xp, Yp) {
      const Px = P.x - O.x;
      const Py = P.y - O.y;
      const Xv = [Xp.x - O.x, Xp.y - O.y];
      const Yv = [Yp.x - O.x, Yp.y - O.y];
      const det = Xv[0]*Yv[1] - Xv[1]*Yv[0];
      if (Math.abs(det) < 1e-6) return [NaN, NaN];
      const a = (Px*Yv[1] - Py*Yv[0]) / det;
      const b = (Py*Xv[0] - Px*Xv[1]) / det;
      return [a, b];
    }

    // 绘制点
    function drawPoint(P, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(P.x, P.y, 5, 0, Math.PI*2);
      ctx.fill();
    }

    // 绘制向量
    function drawVector(O, P, color) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 3; // 更粗
      ctx.beginPath();
      ctx.moveTo(O.x, O.y);
      ctx.lineTo(P.x, P.y);
      ctx.stroke();

      // 箭头
      const angle = Math.atan2(P.y - O.y, P.x - O.x);
      const headlen = 12;
      ctx.beginPath();
      ctx.moveTo(P.x, P.y);
      ctx.lineTo(P.x - headlen*Math.cos(angle - Math.PI/6),
                 P.y - headlen*Math.sin(angle - Math.PI/6));
      ctx.lineTo(P.x - headlen*Math.cos(angle + Math.PI/6),
                 P.y - headlen*Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    // 在目标点旁边标注坐标值
    function drawLabel(P, a, b, color, index) {
      ctx.fillStyle = color;
      ctx.font = "18px 微软雅黑"; // 字体更大
      ctx.fillText(`系${index}: (${a.toFixed(2)}, ${b.toFixed(2)})`, P.x + 12, P.y - 15*index);
    }

    // 重置
    resetBtn.addEventListener("click", () => {
      targetPoint = null;
      tempPoints = [];
      systems = [];
      redraw();
      output.innerHTML = "";
    });
  </script>
</body>
</html>
